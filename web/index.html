<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doze</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(to bottom, #1a1a1a 0%, #0d0d0d 100%);
            color: #e0e0e0;
            font-family: 'SF Mono', 'Monaco', 'Menlo', 'Consolas', 'Liberation Mono', monospace;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .status {
            padding: 0.875rem 1.25rem;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 0.813rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ec9b0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 8px currentColor;
        }

        .status-text {
            font-weight: 500;
            letter-spacing: 0.01em;
        }

        .status.none .status-indicator {
            background: #ce9178;
            color: #ce9178;
        }
        .status.starting .status-indicator {
            background: #dcdcaa;
            color: #dcdcaa;
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .status.waiting .status-indicator {
            background: #4ec9b0;
            color: #4ec9b0;
        }
        .status.active .status-indicator {
            background: #569cd6;
            color: #569cd6;
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .status.shutting_down .status-indicator {
            background: #ce9178;
            color: #ce9178;
        }
        .status.stopped .status-indicator {
            background: #ce9178;
            color: #ce9178;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.4;
                transform: scale(0.95);
            }
        }

        #output {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.875rem;
            line-height: 1.6;
            scroll-behavior: smooth;
        }

        #output::-webkit-scrollbar {
            width: 8px;
        }

        #output::-webkit-scrollbar-track {
            background: transparent;
        }

        #output::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
        }

        #output::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        #input-area {
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            padding: 1.25rem;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.3);
        }

        #input {
            width: 100%;
            padding: 0.875rem 1rem;
            background: rgba(60, 60, 60, 0.5);
            border: 1.5px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 16px; /* Prevents iOS zoom on focus */
            outline: none;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #input:focus {
            background: rgba(60, 60, 60, 0.7);
            border-color: #4ec9b0;
            box-shadow: 0 0 0 3px rgba(78, 201, 176, 0.15);
        }

        #input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .welcome {
            opacity: 0.5;
            text-align: center;
            padding: 3rem 2rem;
            animation: fadeIn 0.6s ease-out;
        }

        .welcome h1 {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .welcome p {
            font-size: 0.938rem;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 0.5;
                transform: translateY(0);
            }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .status {
                padding: 0.75rem 1rem;
                font-size: 0.75rem;
            }

            #output {
                padding: 1rem;
                font-size: 0.813rem;
            }

            #input-area {
                padding: 1rem;
            }

            .welcome h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="status" id="status">
        <div class="status-indicator"></div>
        <span class="status-text" id="status-text">Connecting...</span>
    </div>

    <div id="output">
        <div class="welcome">
            <h1>ðŸ›Œ Doze</h1>
            <p>Chat with Claude Code from anywhere</p>
            <p style="margin-top: 1rem; font-size: 0.8rem;">Type a message to start...</p>
        </div>
    </div>

    <div id="input-area">
        <input
            type="text"
            id="input"
            placeholder="Send a message to Claude..."
            autocomplete="off"
            disabled
        />
    </div>

    <script>
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const statusEl = document.getElementById('status');
        const statusText = document.getElementById('status-text');

        let eventSource;
        let sessionStarted = false;

        // Token management - check URL param, then localStorage
        function getToken() {
            // Check URL param first (for sharing links)
            const urlParams = new URLSearchParams(window.location.search);
            const urlToken = urlParams.get('token');
            if (urlToken) {
                localStorage.setItem('doze_token', urlToken);
                // Clean URL (remove token from visible URL for security)
                window.history.replaceState({}, document.title, window.location.pathname);
                return urlToken;
            }
            return localStorage.getItem('doze_token') || '';
        }

        let authToken = getToken();

        // Helper to add auth header to fetch requests
        function authHeaders(headers = {}) {
            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }
            return headers;
        }

        // Handle 401 errors - prompt for token
        function handleAuthError() {
            const token = prompt('Authentication required. Enter your access token:');
            if (token) {
                localStorage.setItem('doze_token', token);
                authToken = token;
                location.reload();
            }
        }

        function updateStatus(state, text) {
            statusEl.className = `status ${state}`;
            statusText.textContent = text;
        }

        function appendOutput(text, style = '') {
            // Remove welcome message on first output
            const welcome = output.querySelector('.welcome');
            if (welcome) welcome.remove();

            if (style) {
                const span = document.createElement('span');
                span.style.cssText = style;
                span.textContent = text;
                output.appendChild(span);
            } else {
                output.appendChild(document.createTextNode(text));
            }
            output.scrollTop = output.scrollHeight;
        }

        async function startSession() {
            try {
                updateStatus('starting', 'Starting session...');
                const response = await fetch('/start', {
                    method: 'POST',
                    headers: authHeaders({ 'Content-Type': 'application/json' }),
                    body: JSON.stringify({ repo_path: '.' })
                });

                if (response.status === 401) {
                    handleAuthError();
                    return;
                }

                if (response.ok) {
                    sessionStarted = true;
                    updateStatus('waiting', 'Session started');
                } else {
                    const error = await response.json();
                    updateStatus('none', `Failed to start: ${error.error}`);
                }
            } catch (err) {
                updateStatus('none', 'Failed to start session');
                console.error('Start error:', err);
            }
        }

        function connect() {
            // EventSource can't set headers, so pass token as query param
            const streamUrl = authToken ? `/stream?token=${encodeURIComponent(authToken)}` : '/stream';
            eventSource = new EventSource(streamUrl);

            eventSource.onopen = () => {
                input.disabled = false;
            };

            eventSource.onmessage = (e) => {
                const data = JSON.parse(e.data);

                if (data.type === 'output') {
                    appendOutput(data.content);
                }

                if (data.type === 'info') {
                    // Add newline before tool use if output doesn't end with one
                    const lastChar = output.textContent.slice(-1);
                    if (lastChar && lastChar !== '\n') {
                        appendOutput('\n');
                    }
                    appendOutput(data.content + '\n', 'opacity: 0.7;');
                }

                if (data.type === 'error') {
                    appendOutput('[Error] ' + data.content + '\n', 'color: #f48771;');
                }

                if (data.type === 'state') {
                    const stateLabels = {
                        none: 'No session',
                        starting: 'Starting...',
                        active: 'Claude is working...',
                        waiting: 'Ready',
                        shutting_down: 'Stopping...',
                        stopped: 'Session stopped (will resume on message)'
                    };
                    updateStatus(data.state, stateLabels[data.state] || data.state);

                    // Add spacing after Claude finishes responding
                    if (data.state === 'waiting') {
                        appendOutput('\n');
                        input.disabled = false;
                    }

                    if (data.state === 'stopped') {
                        input.disabled = false;
                    }
                }
            };

            eventSource.onerror = (e) => {
                // Check if this is an auth error (EventSource doesn't expose status directly)
                // If we get an immediate error and have no token, likely auth required
                if (eventSource.readyState === EventSource.CLOSED && !sessionStarted) {
                    // Try a status check to see if it's auth
                    fetch('/status', { headers: authHeaders() })
                        .then(r => {
                            if (r.status === 401) {
                                handleAuthError();
                            } else {
                                updateStatus('none', 'Disconnected - reconnecting...');
                                setTimeout(connect, 2000);
                            }
                        })
                        .catch(() => {
                            updateStatus('none', 'Disconnected - reconnecting...');
                            setTimeout(connect, 2000);
                        });
                } else {
                    updateStatus('none', 'Disconnected - reconnecting...');
                    setTimeout(connect, 2000);
                }
                input.disabled = true;
                eventSource.close();
            };
        }

        input.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && input.value.trim()) {
                const message = input.value;
                input.value = '';
                input.disabled = true;

                // Show user message in output
                appendOutput('> ' + message + '\n\n', 'color: #569cd6;');

                // Auto-start session on first message if needed
                if (!sessionStarted) {
                    await startSession();
                    // Small delay to let session initialize
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                try {
                    const response = await fetch('/message', {
                        method: 'POST',
                        headers: authHeaders({ 'Content-Type': 'application/json' }),
                        body: JSON.stringify({ content: message })
                    });

                    if (response.status === 401) {
                        handleAuthError();
                        return;
                    }

                    if (!response.ok) {
                        const error = await response.json();
                        appendOutput(`[Error] ${error.error}\n`, 'color: #f48771;');
                    }
                } catch (err) {
                    appendOutput('[Error] Failed to send message\n', 'color: #f48771;');
                    console.error('Failed to send message:', err);
                } finally {
                    input.disabled = false;
                    input.focus();
                }
            }
        });

        // Connect on load and check status
        connect();

        // Check if session exists
        fetch('/status', { headers: authHeaders() })
            .then(r => {
                if (r.status === 401) {
                    handleAuthError();
                    return null;
                }
                return r.json();
            })
            .then(data => {
                if (data && data.state !== 'none') {
                    sessionStarted = true;
                }
            })
            .catch(() => {});
    </script>
</body>
</html>
